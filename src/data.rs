//! Load and store data in the form of JSON files in a folder hierarchy.
//!
//! User-generated:
//!
//! - `ignore`: gitignore-like, used for stats, not during gathering
//! - `authors.toml`: rename and consolidate authors
//!
//! Generated by blamegraph:
//!
//! - `log.json`: list of commits to use for stats, in reverse chronological order
//! - `commits/<hash>.json`: metadata for a specific commit
//! - `blames/<hash>.json`: blame data for a specific commit

mod authors;
mod blame;
mod commit;

use std::{
    fs,
    io::ErrorKind,
    path::{Path, PathBuf},
};

use anyhow::Context;
use lru::LruCache;
use serde::{de::DeserializeOwned, Serialize};
use tempfile::NamedTempFile;

pub use self::{authors::*, blame::*, commit::*};

fn path_authors(dir: &Path) -> PathBuf {
    dir.join("authors.toml")
}

fn path_log(dir: &Path) -> PathBuf {
    dir.join("log.json")
}

fn path_commit(dir: &Path, hash: &str) -> PathBuf {
    dir.join("commits").join(hash).with_extension("json")
}

fn path_blametree(dir: &Path, hash: &str) -> PathBuf {
    dir.join("blametrees").join(hash).with_extension("json")
}

fn path_blame(dir: &Path, hash: &str) -> PathBuf {
    dir.join("blames").join(hash).with_extension("json")
}

pub struct Data {
    dir: PathBuf,
    commit_cache: LruCache<String, Commit>,
    blametree_cache: LruCache<String, BlameTree>,
    blame_cache: LruCache<String, Blame>,
}

impl Data {
    pub fn new(dir: PathBuf) -> Self {
        Self {
            dir,
            commit_cache: LruCache::new(10000.try_into().unwrap()),
            blametree_cache: LruCache::new(1000.try_into().unwrap()),
            blame_cache: LruCache::new(5000.try_into().unwrap()),
        }
    }

    fn load_json<T: DeserializeOwned>(path: &Path) -> anyhow::Result<T> {
        Ok(serde_json::from_str(&fs::read_to_string(path)?)?)
    }

    fn load_json_with_cache<T: Clone + DeserializeOwned>(
        cache: &mut LruCache<String, T>,
        path: &Path,
        key: String,
    ) -> anyhow::Result<T> {
        if let Some(value) = cache.get(&key) {
            return Ok(value.clone());
        }

        let value =
            Self::load_json::<T>(path).context(format!("failed to load {}", path.display()))?;
        cache.push(key, value.clone());
        Ok(value)
    }

    fn save_json<T: Serialize>(path: &Path, value: &T) -> anyhow::Result<()> {
        let parent = path.parent().unwrap();
        fs::create_dir_all(parent)?;
        let tmp_file = NamedTempFile::new_in(parent)?;
        serde_json::to_writer(&tmp_file, value)?;
        tmp_file.persist(path)?;
        Ok(())
    }

    fn save_json_without_overwriting<T: Serialize>(path: &Path, value: &T) -> anyhow::Result<()> {
        if path.exists() {
            return Ok(());
        }
        Self::save_json(path, value)
    }

    pub fn load_ignore() -> anyhow::Result<()> {
        todo!()
    }

    pub fn load_authors(&self) -> anyhow::Result<Authors> {
        let path = path_authors(&self.dir);
        let authors = match fs::read_to_string(&path) {
            Ok(s) => toml::from_str::<Authors>(&s)?,
            Err(e) if e.kind() == ErrorKind::NotFound => Authors::default(),
            Err(e) => Err(e).context(format!("failed to load authors from {}", path.display()))?,
        };
        authors.check_for_cycles()?;
        Ok(authors)
    }

    pub fn load_log(&self) -> anyhow::Result<Vec<String>> {
        let path = path_log(&self.dir);
        let log = match fs::read_to_string(&path) {
            Ok(s) => serde_json::from_str::<Vec<String>>(&s)?,
            Err(e) if e.kind() == ErrorKind::NotFound => vec![],
            Err(e) => Err(e).context(format!("failed to load log from {}", path.display()))?,
        };
        Ok(log)
    }

    pub fn save_log(&self, log: &Vec<String>) -> anyhow::Result<()> {
        let path = path_log(&self.dir);
        Self::save_json(&path, log).context(format!("failed to save log to {}", path.display()))
    }

    pub fn load_commit(&mut self, hash: String) -> anyhow::Result<Commit> {
        let path = path_commit(&self.dir, &hash);
        Self::load_json_with_cache(&mut self.commit_cache, &path, hash)
    }

    pub fn save_commit(&self, commit: &Commit) -> anyhow::Result<()> {
        let path = path_commit(&self.dir, &commit.hash);
        Self::save_json_without_overwriting(&path, commit)
    }

    pub fn blametree_exists(&self, hash: String) -> bool {
        path_blametree(&self.dir, &hash).exists()
    }

    pub fn load_blametree(&mut self, hash: String) -> anyhow::Result<BlameTree> {
        let path = path_blametree(&self.dir, &hash);
        Self::load_json_with_cache(&mut self.blametree_cache, &path, hash)
    }

    pub fn save_blametree(&self, blametree: &BlameTree) -> anyhow::Result<()> {
        let path = path_blametree(&self.dir, &blametree.commit);
        Self::save_json_without_overwriting(&path, blametree)
    }

    pub fn blame_exists(&self, id: &BlameId) -> bool {
        path_blame(&self.dir, &id.sha256()).exists()
    }

    pub fn load_blame(&mut self, id: &BlameId) -> anyhow::Result<Blame> {
        let path = path_blame(&self.dir, &id.sha256());
        Self::load_json_with_cache(&mut self.blame_cache, &path, id.sha256())
    }

    pub fn save_blame(&self, blame: &Blame) -> anyhow::Result<()> {
        let path = path_blame(&self.dir, &blame.id.sha256());
        Self::save_json_without_overwriting(&path, blame)
    }
}
