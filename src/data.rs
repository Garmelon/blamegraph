//! Load and store data in the form of JSON files in a folder hierarchy.
//!
//! User-generated:
//!
//! - `ignore`: gitignore-like, used for stats, not during gathering
//! - `authors.toml`: rename and consolidate authors
//!
//! Generated by blamegraph:
//!
//! - `log.json`: list of commits to use for stats, in reverse chronological order
//! - `commits/<hash>.json`: metadata for a specific commit
//! - `blames/<hash>.json`: blame data for a specific commit

mod authors;
mod blame;
mod commit;

use std::{
    fs,
    io::ErrorKind,
    path::{Path, PathBuf},
};

use anyhow::Context;
use lru::LruCache;
use serde::{de::DeserializeOwned, Serialize};
use tempfile::NamedTempFile;

pub use self::{authors::*, blame::*, commit::*};

const EXTENSION: &str = "bin";

fn path_authors(dir: &Path) -> PathBuf {
    dir.join("authors.toml")
}

fn path_log(dir: &Path) -> PathBuf {
    dir.join("log").with_extension(EXTENSION)
}

fn path_commit(dir: &Path, hash: &str) -> PathBuf {
    let first_two_chars = hash.split_at(2).0;
    dir.join("commits")
        .join(first_two_chars)
        .join(hash)
        .with_extension(EXTENSION)
}

fn path_blametree(dir: &Path, hash: &str) -> PathBuf {
    let first_two_chars = hash.split_at(2).0;
    dir.join("blametrees")
        .join(first_two_chars)
        .join(hash)
        .with_extension(EXTENSION)
}

fn path_blame(dir: &Path, hash: &str) -> PathBuf {
    let first_two_chars = hash.split_at(2).0;
    dir.join("blames")
        .join(first_two_chars)
        .join(hash)
        .with_extension(EXTENSION)
}

pub struct Data {
    dir: PathBuf,
    commit_cache: LruCache<String, Commit>,
    blametree_cache: LruCache<String, BlameTree>,
    blame_cache: LruCache<String, Blame>,
}

impl Data {
    pub fn new(dir: PathBuf) -> Self {
        Self {
            dir,
            commit_cache: LruCache::new(10000.try_into().unwrap()),
            blametree_cache: LruCache::new(100.try_into().unwrap()),
            blame_cache: LruCache::new(10000.try_into().unwrap()),
        }
    }

    fn load_data_uncached<T: DeserializeOwned>(path: &Path) -> anyhow::Result<T> {
        Ok(bincode::deserialize(&fs::read(path)?)?)
    }

    fn load_data_cached<T: Clone + DeserializeOwned>(
        cache: &mut LruCache<String, T>,
        path: &Path,
        key: String,
    ) -> anyhow::Result<T> {
        if let Some(value) = cache.get(&key) {
            return Ok(value.clone());
        }

        let value = Self::load_data_uncached::<T>(path)
            .context(format!("failed to load {}", path.display()))?;
        cache.push(key, value.clone());
        Ok(value)
    }

    fn save_data<T: Serialize>(path: &Path, value: &T) -> anyhow::Result<()> {
        let parent = path.parent().unwrap();
        fs::create_dir_all(parent)?;
        let tmp_file = NamedTempFile::new_in(parent)?;
        bincode::serialize_into(&tmp_file, value)?;
        tmp_file.persist(path)?;
        Ok(())
    }

    fn save_data_without_overwriting<T: Serialize>(path: &Path, value: &T) -> anyhow::Result<()> {
        if path.exists() {
            return Ok(());
        }
        Self::save_data(path, value)
    }

    pub fn load_ignore_uncached() -> anyhow::Result<()> {
        todo!()
    }

    pub fn load_authors_uncached(&self) -> anyhow::Result<Authors> {
        let path = path_authors(&self.dir);
        let authors = match fs::read_to_string(&path) {
            Ok(s) => toml::from_str::<Authors>(&s)?,
            Err(e) if e.kind() == ErrorKind::NotFound => Authors::default(),
            Err(e) => Err(e).context(format!("failed to load authors from {}", path.display()))?,
        };
        authors.check_for_cycles()?;
        Ok(authors)
    }

    pub fn load_log_uncached(&self) -> anyhow::Result<Vec<String>> {
        let path = path_log(&self.dir);
        let log = match fs::read(&path) {
            Ok(s) => bincode::deserialize::<Vec<String>>(&s)?,
            Err(e) if e.kind() == ErrorKind::NotFound => vec![],
            Err(e) => Err(e).context(format!("failed to load log from {}", path.display()))?,
        };
        Ok(log)
    }

    pub fn save_log(&self, log: &Vec<String>) -> anyhow::Result<()> {
        let path = path_log(&self.dir);
        Self::save_data(&path, log).context(format!("failed to save log to {}", path.display()))
    }

    pub fn load_commit_cached(&mut self, hash: String) -> anyhow::Result<Commit> {
        let path = path_commit(&self.dir, &hash);
        Self::load_data_cached(&mut self.commit_cache, &path, hash)
    }

    pub fn save_commit(&self, commit: &Commit) -> anyhow::Result<()> {
        let path = path_commit(&self.dir, &commit.hash);
        Self::save_data_without_overwriting(&path, commit)
    }

    pub fn blametree_exists(&self, hash: String) -> bool {
        path_blametree(&self.dir, &hash).exists()
    }

    pub fn load_blametree_cached(&mut self, hash: String) -> anyhow::Result<BlameTree> {
        let path = path_blametree(&self.dir, &hash);
        Self::load_data_cached(&mut self.blametree_cache, &path, hash)
    }

    pub fn load_blametree_uncached(&self, hash: String) -> anyhow::Result<BlameTree> {
        let path = path_blametree(&self.dir, &hash);
        Self::load_data_uncached(&path)
    }

    pub fn save_blametree(&self, blametree: &BlameTree) -> anyhow::Result<()> {
        let path = path_blametree(&self.dir, &blametree.commit);
        Self::save_data_without_overwriting(&path, blametree)
    }

    pub fn blame_exists(&self, id: &BlameId) -> bool {
        path_blame(&self.dir, &id.sha256()).exists()
    }

    pub fn load_blame_cached(&mut self, id: &BlameId) -> anyhow::Result<Blame> {
        let path = path_blame(&self.dir, &id.sha256());
        Self::load_data_cached(&mut self.blame_cache, &path, id.sha256())
    }

    pub fn save_blame(&self, blame: &Blame) -> anyhow::Result<()> {
        let path = path_blame(&self.dir, &blame.id.sha256());
        Self::save_data_without_overwriting(&path, blame)
    }
}
